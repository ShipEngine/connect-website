(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4130],{6630:function(e,n,a){"use strict";a.r(n),a.d(n,{title:function(){return s},description:function(){return d},tags:function(){return k},createdAt:function(){return c},modifiedAt:function(){return w},default:function(){return N}});var t,r=a(9016),o=a(3104),i=a(6687),m=a(2320),p=a(1783),l=["components"],s=(i.createElement,"ShipEngine Connect code style guide"),d="The ShipEngine Connect style guide provides style guidance for 3rd party app developers",k=["contrib","ShipEngine Connect","contribution","best","practices","style guide"],c=new Date(1653338063541.9846),w=new Date(1653338063541.9846),u=(t="Pager",function(e){return console.warn("Component "+t+" was not imported, exported, or provided by MDXProvider as global scope"),(0,m.kt)("div",e)}),h=function(e){return(0,m.kt)(p.Z,(0,o.Z)({title:"ShipEngine Connect code style guide",description:"The ShipEngine Connect style guide provides style guidance for 3rd party app developers",tags:["contrib","ShipEngine Connect","contribution","best","practices","style guide"],createdAt:new Date(1653338063542),modifiedAt:new Date(1653338063542)},e))};function N(e){var n=e.components,a=(0,r.Z)(e,l);return(0,m.kt)(h,(0,o.Z)({},a,{components:n,mdxType:"MDXLayout"}),(0,m.kt)("h2",{markdown:!0},"Code style conventions"),(0,m.kt)("p",{markdown:!0},"We suggest that you use the latest ES6 conventions, many are described below."),(0,m.kt)("hr",{markdown:!0}),(0,m.kt)("ol",{markdown:!0},(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Name things logically... ",(0,m.kt)("a",{href:"https://www.nikola-breznjak.com/blog/books/programming/code-complete-2-steve-mcconnell-power-variable-names/",markdown:!0,parentName:"p"},"See reference"),".")),(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Do not use ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"eval"),". ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#never_use_eval!",markdown:!0,parentName:"p"},"See reference"),".")),(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Do not use ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"with"),". ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with#ambiguity_contra",markdown:!0,parentName:"p"},"See reference"),".")),(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"As a general rule do not use primitive type wrapper constructors: ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"new Number"),", ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"new String"),", ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"new Boolean"),", ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"new Array"),", ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"new Object")),(0,m.kt)("ul",{markdown:!0,parentName:"li"},(0,m.kt)("li",{markdown:!0,parentName:"ul"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"If the usage of the type wrapper signifigantly improves the readability of the code, then it may be considered as being worth the trade off."),(0,m.kt)("ul",{markdown:!0,parentName:"li"},(0,m.kt)("li",{markdown:!0,parentName:"ul"},"Example, ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"li"},"Boolean(foo) ")," over ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"li"},"!!isFoo"),"."))),(0,m.kt)("li",{markdown:!0,parentName:"ul"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Primitive type wrappers are slower than their primitive counterparts.")),(0,m.kt)("li",{markdown:!0,parentName:"ul"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"They also cause subtle bugs with ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"instanceof"),".")),(0,m.kt)("li",{markdown:!0,parentName:"ul"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Object's should be created using the object literal syntax."),(0,m.kt)("pre",{markdown:!0,parentName:"li"},(0,m.kt)("code",{className:"language-js",markdown:!0,parentName:"pre"},"// Bad.\nvar obj = new Object();\nconst obj = Object.create(Object.prototype);\n\n// Good.\nconst obj = {};\n"))),(0,m.kt)("li",{markdown:!0,parentName:"ul"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Object declarations should:"),(0,m.kt)("ul",{markdown:!0,parentName:"li"},(0,m.kt)("li",{markdown:!0,parentName:"ul"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Have a space between the curly braces.")),(0,m.kt)("li",{markdown:!0,parentName:"ul"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"For single-line declarations, the last value should not end in a comma.\nFor multi-line declarations, each line should end with a comma (including the last line). This will make it easier to add properties and result in a smaller diff for the reviewer.")),(0,m.kt)("li",{markdown:!0,parentName:"ul"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"There should not be a space before the colon, but there should be one after it."),(0,m.kt)("pre",{markdown:!0,parentName:"li"},(0,m.kt)("code",{className:"language-js",markdown:!0,parentName:"pre"},"// Bad.\nconst a = {\n  k1 : v1,\n  k2: v2\n};\nconst b = { k1: v1, k2 : v2, };\nconst c = {k1:v1};\n\n// Good.\nconst a = {\n  k1: v1,\n  k2: v2,\n};\nconst b = { k1: v1, k2: v2 };\nconst c = { k1: v2 };\n"))))),(0,m.kt)("li",{markdown:!0,parentName:"ul"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Arrays should be created using the array literal syntax."),(0,m.kt)("pre",{markdown:!0,parentName:"li"},(0,m.kt)("code",{className:"language-js",markdown:!0,parentName:"pre"},"// Bad.\nconst a = new Array();\n\n// Good.\nconst a = [];\n"))))),(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Favor ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"const")," and ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"let")," over ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"var"),"."),(0,m.kt)("ul",{markdown:!0,parentName:"li"},(0,m.kt)("li",{markdown:!0,parentName:"ul"},(0,m.kt)("p",{markdown:!0,parentName:"li"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"var")," is a legacy keyword and there are no practical use cases for ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"var")," in modern ES6."),(0,m.kt)("ul",{markdown:!0,parentName:"li"},(0,m.kt)("li",{markdown:!0,parentName:"ul"},"Never use ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"li"},"var"),"."))),(0,m.kt)("li",{markdown:!0,parentName:"ul"},(0,m.kt)("p",{markdown:!0,parentName:"li"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"const")," is the default. This prevents the variable from being re-assigned, however a ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"const")," object can still be mutated; if you need true immutability, consider using ",(0,m.kt)("a",{href:"http://facebook.github.io/immutable-js/",markdown:!0,parentName:"p"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"immutable-js")),".")),(0,m.kt)("li",{markdown:!0,parentName:"ul"},(0,m.kt)("p",{markdown:!0,parentName:"li"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"let")," only when the value of the variable must be re-assigned. This is allowed, but it is commonly a sign that you should refactor the code to prevent the need to use ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"let"),".")))),(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"When applicable, use ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of",markdown:!0,parentName:"p"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"for..of"))," and ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in",markdown:!0,parentName:"p"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"for..in"))," instead of ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for",markdown:!0,parentName:"p"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"for..i")),"."),(0,m.kt)("ul",{markdown:!0,parentName:"li"},(0,m.kt)("li",{markdown:!0,parentName:"ul"},"In most cases you should favor ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach",markdown:!0,parentName:"li"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"forEach"))," and ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map",markdown:!0,parentName:"li"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"map")),"."),(0,m.kt)("li",{markdown:!0,parentName:"ul"},"Also in instances when you need to ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter",markdown:!0,parentName:"li"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"filter"))," and then ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map",markdown:!0,parentName:"li"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"map"))," the results of the ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter",markdown:!0,parentName:"li"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"filter"))," operation... You should use a single iteration to achieve the same result via the ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce",markdown:!0,parentName:"li"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"reduce"))," function."))),(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Use the ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes",markdown:!0,parentName:"p"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"class"))," keyword instead of the ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions",markdown:!0,parentName:"p"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"function"))," keyword for ES6 classes. IE, you should not be calling ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new",markdown:!0,parentName:"p"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"new"))," against a ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions",markdown:!0,parentName:"p"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"function")),"."),(0,m.kt)("pre",{markdown:!0,parentName:"li"},(0,m.kt)("code",{className:"language-js",markdown:!0,parentName:"pre"},'// Bad.\nfunction MyClass() {\n  this.someProp = "A value";\n}\nconst instance = new MyClass();\n\n// Good.\nclass MyClass {\n  constructor(prop) {\n        this.someProp = prop\n  }\n}\nconst instance = new MyClass();\n'))),(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"When anonymous funcitons are used, you should use a lambda / ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions",markdown:!0,parentName:"p"},"arrow functions"),"."),(0,m.kt)("pre",{markdown:!0,parentName:"li"},(0,m.kt)("code",{className:"language-js",markdown:!0,parentName:"pre"},"const array1 = [1, 4, 9, 16];\n\n// Bad.\nconst badMap = array1.map(function( x ) { return x * 2});\nconst lessBadMap = array1.map(function mapData( x ) { return x * 2});\n\n// Good.\nconst goodMap = array1.map(x => x * 2);\nconst bestMap = array1.map((x) => x * 2);\n"))),(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Favor ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions",markdown:!0,parentName:"p"},"arrow functions")," over context binding."),(0,m.kt)("pre",{markdown:!0,parentName:"li"},(0,m.kt)("code",{className:"language-js",markdown:!0,parentName:"pre"},"function myMethod(...params) { /* logic here*/ }\n\n// Bad.\nconst self = this;\nconst boundMethod = function(...params) {\n  return myMethod.apply(self, params);\n}\n\n// Less bad.\nconst boundMethod = myMethod.bind(this);\n\n// Best.\nconst boundMethod = (...params) => myMethod.apply(this, params);\n"))),(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Use ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment",markdown:!0,parentName:"p"},"destructuring")," when applicable."),(0,m.kt)("pre",{markdown:!0,parentName:"li"},(0,m.kt)("code",{className:"language-js",markdown:!0,parentName:"pre"},"function myFunction(person) {\n  const { firstName, lastName } = person\n}\n"))),(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Named params are preferred, however if varaidic expansion is required... always favor the ES6 ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters",markdown:!0,parentName:"p"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"...rest"))," syntax over inspecting the ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments",markdown:!0,parentName:"p"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"arguments")," object"),".")),(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Options params should be passed in via an object... instead of as a named param."),(0,m.kt)("ul",{markdown:!0,parentName:"li"},(0,m.kt)("li",{markdown:!0,parentName:"ul"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"This allows the options to be passed with differing data without changing how the function is called.")),(0,m.kt)("li",{markdown:!0,parentName:"ul"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Additionally it helps to prevent truthiness bugs when booleans are passed. See ",(0,m.kt)("a",{href:"https://ariya.io/2011/08/hall-of-api-shame-boolean-trap",markdown:!0,parentName:"p"},"boolean trap anti-pattern"),"."),(0,m.kt)("pre",{markdown:!0,parentName:"li"},(0,m.kt)("code",{className:"language-js",markdown:!0,parentName:"pre"},"// Bad.\nfunction apiCall(a, b, isMock = false ) { }\n\n// Good.\nfunction apiCall(a, b, { isMock = false } = {}) {}\n"))))),(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Dot notation usage should be consistent."),(0,m.kt)("pre",{markdown:!0,parentName:"li"},(0,m.kt)("code",{className:"language-js",markdown:!0,parentName:"pre"},"// Bad.\nobj.x = 123;\nobj['y'] = 321;\n\n// Ok, if needed.\nobj['x'] = 123;\nobj['y-z'] = 321;\n\n// Best.\nobj.x = 123;\nobj.y = 321;\n"))),(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Always use strict comparison operators."),(0,m.kt)("ul",{markdown:!0,parentName:"li"},(0,m.kt)("li",{markdown:!0,parentName:"ul"},"Do not use ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"li"},"!=")," and ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"li"},"=="),"."),(0,m.kt)("li",{markdown:!0,parentName:"ul"},"Use these instead ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"li"},"!==")," and ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"li"},"==="),"."),(0,m.kt)("li",{markdown:!0,parentName:"ul"},"Prefer explicit strict value checks over truthiness checks."),(0,m.kt)("li",{markdown:!0,parentName:"ul"},"Do not use forced boolean casting => ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"li"},"if(!!value)"),"."))),(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Method chains must start with a leading dot."),(0,m.kt)("pre",{markdown:!0,parentName:"li"},(0,m.kt)("code",{className:"language-js",markdown:!0,parentName:"pre"},"// Bad.\nmyPromise.then(() => {}).\n  then(() => {}).\n  catch((ex) => {})\n\n// Good.\nmyPromise\n  .then(() => {})\n  .catch((ex) => {})\n"))),(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Though the example above uses a ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",markdown:!0,parentName:"p"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"Promise"))," to demonstrate preferred syntax for method chaining, you should prefer the ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function",markdown:!0,parentName:"p"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"async"))," / ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await",markdown:!0,parentName:"p"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"await"))," pattern over the ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",markdown:!0,parentName:"p"},(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},"Promise"))," pattern, ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await",markdown:!0,parentName:"p"},"see reference"),". Suggested ",(0,m.kt)("a",{href:"https://javascript.info/async-await#:~:text=The%20word%20%E2%80%9Casync%E2%80%9D%20before%20a,in%20a%20resolved%20promise%20automatically.&text=So%2C%20async%20ensures%20that%20the,wraps%20non%2Dpromises%20in%20it.",markdown:!0,parentName:"p"},"further reading here"),"."),(0,m.kt)("pre",{markdown:!0,parentName:"li"},(0,m.kt)("code",{className:"language-js",markdown:!0,parentName:"pre"},'import axios from "axios"\n\n// Best: no await needed, just return the Promise from the async call\n// made within your function.\nasync function makeGetCall(endpoint) {\n  return axios.get(endpoint)\n}\n\n// Good: Await the response and return its resolved value.\nasync function makeGetCall(endpoint) {\n    try {\n      const response = await axios.get(endpoint)\n      // Do work with response.\n      return response\n    } catch(error) {\n      // Handle error.\n    }\n}\n\n// ########################################################################\n\n// Bad: There is no asyncronous processing happening here, so this\n// should not be marked as an async function.\nasync function parseJson( jsonStr ) {\n  try {\n    return Promise.resolve(JSON.parse(jsonStr))\n  }\n  catch(error) {\n    return Pomise.reject(error)\n  }\n}\n\n// Bad: Prefer to await Promises instead of then() / catch() handlers.\nasync function makeGetCall(endpoint) {\n  return new Promise( (resolve, reject) => {\n    axios.get(endpoint)\n      .then( (response) => {\n        resolve(response)\n      })\n      .catch( (error) => {\n        reject(error)\n      })\n  })\n}\n\n// Bad: When awaiting a Promise there is no need to\n// chain then() / catch() handlers.\nasync function makeGetCall(endpoint) {\n  const response = await axios.get(endpoint)\n    // These handlers add no functional value.\n    .then( (response) => response )\n    .catch( (error) => { throw error } );\n\n    return response\n}\n\n// Bad: There is no need to create our own Promise, as the axios.get()\n// function returns a Promise that can be used as the return value.\nasync function makeGetCall(endpoint) {\n  return new Promise( (resolve, reject) => {\n    try {\n      const response = await axios.get(endpoint)\n      resolve(response)\n    } catch(error) {\n      reject(error)\n    }\n  })\n}\n')))),(0,m.kt)("ol",{start:17,markdown:!0},(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Prefer the ",(0,m.kt)("strong",{markdown:!0,parentName:"p"},(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining",markdown:!0,parentName:"strong"},"optional chaining (",(0,m.kt)("inlineCode",{markdown:!0,parentName:"a"},".?"),")"))," operator over explicit ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"null")," / ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"undefined")," / truthy checks for nested data (requires >= node 14)."),(0,m.kt)("pre",{markdown:!0,parentName:"li"},(0,m.kt)("code",{className:"language-js",markdown:!0,parentName:"pre"},"let person = { employer: { name: 'Acme' }, fistName: 'John', lastName: 'Doe' };\n// console.log(person.employer.name) => 'Acme'\n\n// Re-defined the person, without an employer name.\nperson = { employer: {}, fistName: 'John', lastName: 'Doe' };\n\n// Bad\nconst coNameBad = (\n  person.employer !== undefined &&\n  person.employer !== null &&\n  person.employer.name !== undefined &&\n  person.employer.name !== null\n) ? person.name : undefined;\n// coNameBad => undefined\n\n// Good.\nconst coNameGood = person.employer?.name;\n// coNameGood => undefined\n"))),(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Prefer the ",(0,m.kt)("strong",{markdown:!0,parentName:"p"},(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator",markdown:!0,parentName:"strong"},"nullish coalescing operator"))," (",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"??"),") over explicit ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"null")," / ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"undefined")," / truthy checks  (requires >= node 14)."),(0,m.kt)("pre",{markdown:!0,parentName:"li"},(0,m.kt)("code",{className:"language-js",markdown:!0,parentName:"pre"},'const y = null;\n\n// Bad\nconst x = (y === undefined || y === null || !y) ? "default value" : y;\n\n// Good.\nconst x = y ?? "default value"\n'))),(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Do not nest ",(0,m.kt)("strong",{markdown:!0,parentName:"p"},(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator",markdown:!0,parentName:"strong"},"ternary operators"))," ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"(?:)"),". This is a readability issue.")),(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Favor ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"import { myFunc } from './path/to/module';")," instead of ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"const myFunc = require('./path/to/module');"),", ",(0,m.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import",markdown:!0,parentName:"p"},"see reference"),".")),(0,m.kt)("li",{markdown:!0,parentName:"ol"},(0,m.kt)("p",{markdown:!0,parentName:"li"},"Do not use the ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"delete")," keyword unless you have to... Instead prefer setting the value of the key to ",(0,m.kt)("inlineCode",{markdown:!0,parentName:"p"},"null")," instead. This is a performance consideration."))),(0,m.kt)(u,{prev:"/docs/contributing",prevTitle:"Contribution Guide",next:"/docs/cli",nextTitle:"Using the CLI",mdxType:"Pager"}))}N.isMDXComponent=!0},685:function(e,n,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/style",function(){return a(6630)}])}},function(e){e.O(0,[1783,2888,9774,179],(function(){return n=685,e(e.s=n);var n}));var n=e.O();_N_E=n}]);